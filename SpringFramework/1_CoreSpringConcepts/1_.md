# 🌟 Java Spring Framework: Core Concepts Guide

## 1. 🔄 Dependency Injection & Inversion of Control
---------

Dependency Injection (DI) and Inversion of Control (IoC) are fundamental principles in Spring that form the backbone of the framework.

### 🎯 What is Inversion of Control?

IoC is a design principle where control over program flow is transferred from your code to the framework. In traditional programming, your application code calls the framework. With IoC, the framework calls your code.

```
Traditional Flow:  Your Code → Framework Libraries
IoC Flow:          Framework → Your Code
```

### 🔄 What is Dependency Injection?

DI is an implementation of IoC where objects receive their dependencies rather than creating them internally.

✅ **Benefits:**
- Decoupled code
- Easier unit testing
- Simplified configuration management
- Better code maintainability

❌ **Common Interview Traps:**
- Confusing IoC with DI (IoC is the principle, DI is a pattern implementing it)
- Not understanding the different types of DI in Spring

### 📌 Types of Dependency Injection in Spring

1. **Constructor Injection**:
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    @Autowired  // Optional in newer Spring versions
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

2. **Setter Injection**:
```java
@Service
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

3. **Field Injection**:
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

### 🏆 Best Practices

- **Prefer constructor injection** over other types (immutability, mandatory dependencies)
- Use `final` fields with constructor injection
- Avoid field injection in production code (harder to test)
- Keep components focused (Single Responsibility Principle)

### 🎭 Spring IoC Container

Spring has two main IoC container implementations:

1. **BeanFactory** - basic container, lazy initialization
2. **ApplicationContext** - enterprise-ready container with more features (extends BeanFactory)

```java
// Creating IoC container
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
// or
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

// Getting bean from container
UserService userService = context.getBean(UserService.class);
```

### 📝 Interview Insights

- Be ready to explain the difference between IoC and DI
- Understand when to use different types of injection
- Know why constructor injection is generally preferred
- Explain the benefits of using an IoC container

## 2. 🌱 Spring Bean Lifecycle
---------

The Spring Bean Lifecycle is a crucial concept to understand how beans are created, initialized, and destroyed within the Spring container.

### 🔄 Bean Lifecycle Phases

```
 ┌───────────────┐     ┌──────────────┐     ┌────────────────┐     ┌────────────┐
 │ Instantiation │  →  │ Populate     │  →  │ Pre-           │  →  │ Post-      │
 │               │     │ Properties   │     │ Initialization │     │ Init       │
 └───────────────┘     └──────────────┘     └────────────────┘     └────────────┘
                                                                         │
                                                                         ▼
 ┌───────────────┐     ┌──────────────┐     ┌────────────────┐     ┌────────────┐
 │ Destruction   │  ←  │ Pre-         │  ←  │    Bean in     │  ←  │ Ready for  │
 │               │     │ Destruction  │     │    Use         │     │ Use        │
 └───────────────┘     └──────────────┘     └────────────────┘     └────────────┘
```

### 📌 Lifecycle Callback Methods

Spring provides multiple ways to tap into bean lifecycle:

1. **Interface-based callbacks**:
```java
@Component
public class UserService implements InitializingBean, DisposableBean {
    @Override
    public void afterPropertiesSet() throws Exception {
        // Init code
    }
    
    @Override
    public void destroy() throws Exception {
        // Cleanup code
    }
}
```

2. **Annotation-based callbacks**:
```java
@Component
public class UserService {
    @PostConstruct
    public void init() {
        // Init code
    }
    
    @PreDestroy
    public void cleanup() {
        // Cleanup code
    }
}
```

3. **XML configuration callbacks**:
```xml
<bean id="userService" class="com.example.UserService" init-method="init" destroy-method="cleanup"/>
```

4. **@Bean annotation callbacks**:
```java
@Configuration
public class AppConfig {
    @Bean(initMethod = "init", destroyMethod = "cleanup")
    public UserService userService() {
        return new UserService();
    }
}
```

### 🧩 Bean Scopes

Spring beans can have different scopes:

- **singleton** (default) - one instance per Spring container
- **prototype** - new instance every time requested
- **request** - one instance per HTTP request (web-aware contexts)
- **session** - one instance per HTTP session (web-aware contexts)
- **application** - one instance per ServletContext (web-aware contexts)
- **websocket** - one instance per WebSocket (web-aware contexts)

```java
@Component
@Scope("prototype")
public class UserService {
    // ...
}
```

### ❌ Common Mistakes & Traps

- Using `@PostConstruct` with static methods (won't work)
- Expecting prototype beans to be destroyed by Spring (they aren't)
- Circular dependencies breaking bean initialization
- Not understanding eager vs. lazy initialization
- Ignoring potential race conditions in bean initialization

### ✅ Best Practices

- Keep initialization code fast and simple
- Don't call methods that might use other uninitialized beans in `@PostConstruct`
- Use constructor injection for mandatory dependencies
- Release resources properly in destruction callbacks
- Favor `@PostConstruct` and `@PreDestroy` over interface implementations

### 📊 Bean Processing Order

1. Bean definitions are loaded
2. Bean definitions are post-processed by BeanFactoryPostProcessors
3. Bean instances are created
4. Properties/dependencies are set
5. BeanPostProcessor's `postProcessBeforeInitialization` is called
6. `@PostConstruct` methods are called
7. `InitializingBean.afterPropertiesSet()` is called
8. Custom init methods are called
9. BeanPostProcessor's `postProcessAfterInitialization` is called
10. Bean is ready to use
11. When context is closed/destroyed:
12. `@PreDestroy` methods are called
13. `DisposableBean.destroy()` is called
14. Custom destroy methods are called

## 3. 🚀 Quick Summary
---------

### 📌 Key Takeaways - Dependency Injection & IoC

- **IoC**: Framework controls program flow instead of application code
- **DI**: A pattern implementing IoC where objects receive their dependencies
- **Types of DI**: Constructor (preferred), Setter, Field injection
- **Spring IoC containers**: BeanFactory (basic), ApplicationContext (feature-rich)
- **Benefits**: Loose coupling, testability, maintainability

### 📌 Key Takeaways - Bean Lifecycle

- **Lifecycle phases**: Instantiation, Property Population, Initialization, Use, Destruction
- **Callback approaches**: Interface-based, Annotations (@PostConstruct, @PreDestroy), XML/Java config
- **Bean Scopes**: singleton (default), prototype, request, session, application, websocket
- **Initialization Order**: DI → BeanPostProcessor before → @PostConstruct → afterPropertiesSet → init-method → BeanPostProcessor after

## 4. 📊 Quick Reference Tables
---------

### 🔄 Dependency Injection Types

| Type | Pros | Cons | Best For |
|------|------|------|----------|
| Constructor | Immutable, mandatory dependencies | More verbose for many dependencies | Most scenarios, required dependencies |
| Setter | Good for optional dependencies | Not immutable, can be called multiple times | Optional or changeable dependencies |
| Field | Less code, cleaner look | Hard to unit test, hides dependencies | Prototyping, demo code |

### 🌱 Bean Lifecycle Methods

| Method Type | Implementation | Pros | Cons |
|-------------|----------------|------|------|
| @PostConstruct | Annotation on method | Clean, standard Java EE | Requires JSR-250 API |
| @PreDestroy | Annotation on method | Clean, standard Java EE | Requires JSR-250 API |
| InitializingBean | Interface implementation | No extra dependencies | Couples to Spring |
| DisposableBean | Interface implementation | No extra dependencies | Couples to Spring |
| init-method | XML or @Bean attribute | Works with 3rd party classes | Configuration overhead |
| destroy-method | XML or @Bean attribute | Works with 3rd party classes | Configuration overhead |

### 🧩 Bean Scopes

| Scope | Description | Use Case |
|-------|-------------|----------|
| singleton | One instance per container | Stateless services, repositories |
| prototype | New instance per request | Stateful objects |
| request | One per HTTP request | Web request data |
| session | One per HTTP session | User session data |
| application | One per ServletContext | Application-level data |
| websocket | One per WebSocket | WebSocket connections |

## 5. 🎓 Interview Ready Q&A
---------

### 📌 Common Interview Questions - Dependency Injection & IoC

1. **Q**: What's the difference between IoC and DI?
   **A**: IoC is a design principle where the framework controls program flow. DI is one implementation of IoC where objects receive dependencies rather than creating them.

2. **Q**: Why is constructor injection generally preferred?
   **A**: It enforces mandatory dependencies, allows for immutable objects (final fields), and makes unit testing easier since dependencies are clearly defined.

3. **Q**: How would you handle circular dependencies in Spring?
   **A**: Avoid them through better design or use setter injection. Constructor injection will fail with circular dependencies.

### 📌 Common Interview Questions - Bean Lifecycle

1. **Q**: What happens if you have both implements InitializingBean and @PostConstruct?
   **A**: Both will execute in order: @PostConstruct first, then afterPropertiesSet().

2. **Q**: How are prototype-scoped beans managed in Spring?
   **A**: Spring creates new instances but doesn't manage their destruction. You're responsible for cleaning up prototype beans.

3. **Q**: What's the difference between eager and lazy initialization?
   **A**: Eager (default) initializes beans at startup. Lazy initializes them when first requested. Configure with @Lazy annotation.

4. **Q**: How can you ensure a bean is initialized after another specific bean?
   **A**: Use the @DependsOn annotation to explicitly control initialization order.

---

Happy Spring learning! Remember to practice using these concepts in real code examples to solidify your understanding for interviews. Good luck! 🍀